I have this error, can you take a look into my code and see what's wrong first?

Hydration failed because the server rendered HTML didn't match the client.
As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used.

"use client";

import styles from "./page.module.css";
import { messageHandlers } from "../app/utils/messageHandlers";
import { chatlogHandlers } from "../app/utils/chatlogHandlers";
import { postHandlers } from "./utils/postHandlers";

/**
 * Start Development Server:
 * npm run dev
 */

export default function Home() {
  const { message, handleChange, handleSubmit } = messageHandlers();
  const { printMessage, addUserMessage, addDerbyMessage } = chatlogHandlers();
  const { chatlogs, connectionLoading, messageLoading, getConnection, postMessage } = postHandlers();

  // // useEffect will now run once when the component mounts
  // useEffect(() => {
  //     getConnection();
  // }, [getConnection]); // Empty dependency array ensures the effect runs only once

  return (
    <div className={styles.page}>

      <div className={styles.loaderContainer}>
        {connectionLoading ? 
        <div className={styles.loader}>
        </div> 
        : null}
      </div>

      <main className={styles.main}>
        <div id="chatContainer" className={styles.chatContainer}>
          {chatlogs.map((chat, index) => (
            <div key={index} className={chat.className}>
              <p>
                {chat.content}
              </p>
            </div>
          ))}
        </div>
        <div className={styles.messageContainer}>
          <form className={styles.messageForm} onSubmit={handleSubmit}>
            <input className={styles.messageInput} type="text" value={message} onChange={handleChange} placeholder="Message Derby"></input>
            <div className={styles.buttonContainer}>
              <button onClick={() => {postMessage(message);}} className={styles.submitMessage} type="submit">&gt;</button>
            </div>
          </form>
        </div>
      </main>

      <footer className={styles.footer}>
        <p className={styles.footerContent}>&copy; 2025 Adam</p>
        <p className={styles.footerContent}>Powered by Meta Ollama3</p>
      </footer>

    </div>
  );
}


import { useCallback, useState, useMemo } from 'react';
import { chatlogHandlers } from "../utils/chatlogHandlers";

const BASE_URL = 'https://four-derby-ai-chatbot-backend.onrender.com';

export function postHandlers(){
    const [connectionLoading,setConnectionLoading] = useState(false);
    const [messageLoading,setMessageLoading] = useState(false);
        
    const { chatlogs, addUserMessage, addDerbyMessage } = chatlogHandlers();

    const getConnection = useCallback(async () => {
        const data = { Data: "Client Connection : Successful" }; // Scoped inside function
        try{
            // setConnectionLoading(true);
            const response = await fetch( BASE_URL + '/getNetworkConnection' ,{
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(data),
            });
            // Check if the response is OK (status 200-299)
            if (!response.ok) {
                throw new Error(`Server error: ${response.status}`);
            }
            // Parse the JSON response
            const result = await response.json();

            // Handle the successful response
            console.log("Check Connection Success:", result);
        }
        catch(error:any){
            // setConnectionLoading(false);
            console.error(`Error : ${error.message}`)
        }
        finally{
            // setConnectionLoading(false);
            console.log("Check Connection Complete")
        }
    },[]);

    // const checkConnection = async () => {
    //     // useEffect will now run once when the component mounts
    //     useEffect(() => {
    //         getConnection();
    //     }, [getConnection]); // Empty dependency array ensures the effect runs only once
    // }

    let chat: string = useMemo(() => (""),[]);
    const postMessage = useCallback(async (message: string) => {
        // Render user's message into the chat
        addUserMessage(message);
        // Store user's messages to use as context and history for Ollama3 to reply with context and accuracy.
        chat += `\nUser : ${message}`;
        // Format the message and chat context/history as an object to send as a post method
        const data = { Message: message, Chat:chat }
        console.log(`MESSAGE : ${message} | CHAT : ${JSON.stringify(data.Chat)}`);
        try{
            const response = await fetch ( BASE_URL + "/postMessage" , {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(data),
            });
            // Check if the response is OK (status 200-299)
            if (!response.ok) {
                throw new Error(`Server error: ${response.status}`);
            }
            // Parse the JSON response
            const result = await response.json();
            // Handle the successful response
            console.log("Post Message Success:", result);
            // Render the Ollama3 response into the chat
            chat += `\nAI : ${result.message}`;
            addDerbyMessage(result.message);
        }
        catch(error:any){
            console.error(error.message);
        }
        finally{
            console.log("Message Processing Complete")
        }
    },[chat, addDerbyMessage]);

    return { chatlogs, connectionLoading, messageLoading, getConnection, postMessage }
}

/**
 * Back up for postMessage()
 * let chat: string = useMemo(() => (""),[]);
 *     const postMessage = useCallback(async (message: string) => {
        // Render user's message into the chat
        addUserMessage(message);
        // Store user's messages to use as context and history for Ollama3 to reply with context and accuracy.
        chat += `\nUser : ${message}`;
        // setChat((prev) => prev + `\nUser: ${message}`);
        // Format the message and chat context/history as an object to send as a post method
        const data = { Message: message, Chat:chat }
        console.log(`MESSAGE : ${message} | CHAT : ${JSON.stringify(data.Chat)}`);
        try{
            const response = await fetch ( BASE_URL + "/postMessage" , {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(data),
            });
            // Check if the response is OK (status 200-299)
            if (!response.ok) {
                throw new Error(`Server error: ${response.status}`);
            }
            // Parse the JSON response
            const result = await response.json();
            // Handle the successful response
            console.log("Post Message Success:", result);
            // Render the Ollama3 response into the chat
            // setChat((prev) => prev + `\nAI: ${message}`);
            chat += `\nAI : ${result.message}`;
            addDerbyMessage(result.message);
        }
        catch(error:any){
            console.error(error.message);
        }
        finally{
            console.log("Message Processing Complete")
        }
    },[chat, addDerbyMessage]);
 */

 import styles from "../page.module.css";
import { useState } from "react";

export function chatlogHandlers(){

    const [chatlogs, setChatlogs] = useState<{className:string; content: string}[]>([]);

    const addUserMessage = (message: string) => {
        setChatlogs((chatlogs) => [
            ...chatlogs,
            {className: styles.userMessage , content: message},
        ]);
    };

    const addDerbyMessage = (message: string) => {
        setChatlogs((chatlogs) => [
            ...chatlogs,
            {className: styles.derbyMessage, content: message},
        ]);
    };

    const printMessage = (message: string) => {
        console.log(message);
    };

    return { chatlogs, printMessage, addUserMessage, addDerbyMessage };
}

import { useState } from "react";

// Initialize the event type for event handlers.
type e = React.ChangeEvent<HTMLInputElement>;
type f = React.FormEvent<HTMLFormElement>;
  
export function messageHandlers(){

    const [message, setMessage] = useState("");

    const handleChange = (event:e) => {
        setMessage(event.target.value);
    };

    const handleSubmit = (event:f) => {
        event.preventDefault();
        setMessage("");
    }

    return { message, handleChange, handleSubmit };
}